# 일정 관리 프로그램 매뉴얼
## 1. 프로그램 시작 시
  - event.txt, habit.txt, last_id.txt가 있는지 확인 (없다면 생성 및 필요 값들 초기화)
  - Event 배열, Habit 배열, last_id를 가져옴
  - 이후 event_count, habit_count 등 필요한 모든 전역변수들에 대해 초기화 혹은 로딩을 거침
## 2. 기본 정보 로딩 후, 메인 동작
- 사용자에게 '월 달력' 형식으로 화면을 보여줌
- 이후 메뉴창을 보여주고 입력을 대기 (0 들어오면 while 종료)
- 메뉴창은 아래와 같음 (1~4 switch)
  - ## 1 ) 달력 형식 변경
    - 월, 주, 일 중에 선택 -> 마찬가지로 입력 받아서 선택
    - 화면 제공 후, 다시 메뉴창을 보여주고 선택을 대기
  - ## 2 ) 일정 관리
      ### 2-1 ) 일정 추가
      - 각 필드에 대해 입력을 받음
      - 아래는 필드
        ```c
        Event {
        int id;   // (PK)
        char title[50];
        Time date_start;
        Time date_end;
        double interval;    // 마감일 - 시작일
        double Dday;        // 마감일 - 현재일
        double weight;      // 가중치 (5 ~ 0)
        double quantity;    // 분량
        char details[100];
        }

        Time {
        int year;
        int month;
        int day;
        int hour;
        int minute;
        }
        // 기본값 0으로 세팅은 추가 함수에서 세팅해줘야 함
        ```
      - 각 필드에 대해 유효성 검사하는 과정 필요
      - Dday의 경우, 현재일이 변경되었는지 확인하는 검증 함수를 주기적으로 작동시켜서 업데이트 필요
      - 올바르게 입력된 경우 Event 배열에 추가 & last_id 변경

      ---

    ### 2-2 ) 일정 삭제 (리스트 보여주는 과정은 함수에 포함 안함)
      - 현재 월, 주, 일 형식에 따라서 일정을 보여줌 (시작의 calendar와 동일)
      - 사용자가 선택한 일정 -> 해당하는 id로 매핑해서 인식
      - 해당하는 id를 Event 배열에서 삭제

      ---

    ### 2-3 ) 일정 수정 (리스트 보여주는 과정은 함수에 포함 안함)
      - 현재 월, 주, 일 형식에 따라서 일정을 보여줌 (시작의 calendar와 동일)
      - 사용자가 선택한 일정 -> 해당하는 id로 매핑해서 인식
      - 이후 deleteEvent 후, addEvent를 작동해서 수정된 것처럼 작동하도록 함
  - ## 3 ) 목표 관리
      ### 3-1 ) 목표 추가
      - 각 필드에 대해 입력을 받음
      - 아래는 필드
        ```c
        Habit {
        char name[30];    // 목표 이름 (PK)
        int days;       // 목표 지속 성공 일수
        int is_done;    // 해당 일 목표 성공여부
        }
        // 기본값 0으로 세팅은 추가 함수에서 세팅해줘야 함
        ```
      - 각 필드에 대해 유효성 검사하는 과정 필요
      - is_done의 경우도, 예를 들어 매일 6시에 반복한다고 하면 다음날 6시가 되었는지 확인하는 함수를 돌려서 6시 이후 이 값을 다시 0으로 돌리는 작업이 필요하지 않을까 생각합니다.
      - 올바르게 입력된 경우 Habit 배열에 추가
        - 이 경우 PK를 name으로 사용하고 있기 때문에 last_id가 필요없음 (이름 중복은 없다고 가정)
        - 그러면 이름 중복을 검사하는 과정이 필요함

      ---

      ### 3-2 ) 목표 삭제 (리스트 보여주는 과정은 함수에 포함 안함)
      - 목표 리스트를 사용자에게 전부 보여줌
      - 선택한 name에 해당하는 habit을 Habit 배열에서 삭제

      ---

      ### 3-3 ) 목표 수정
      - 목표 리스트를 사용자에게 전부 보여줌
      - 이후 deleteHabit, addHabit을 작동해서 수정된 것처럼 작동하도록 함
  - ## 4 ) 일정 스케줄링 (가중치) 
      ### 스케줄링 가중치 계산
      ```c
        // 남은 작업량을 고려: 
        // quantity를 활용하여 마감일까지 해야 할 작업량의 비율로 가중치를 조정.
        weight = (1 / Dday) * 100 + priority + (quantity / interval)
        // 가중치에 페널티 부여: 
        // 마감일까지의 여유 시간이 적을수록 높은 페널티를 추가하여 급박한 일정을 더 우선적으로 처리
        weight = (1 / Dday) * 100 + priority + penalty  // 여기서 penalty = (10 / Dday)
      ```
      - 이런 식으로 제공하고자 하는 기능에 따라 필요한 필드 값이 달라집니다.
      - 계산 식은 gpt에게 물어봐서 잘 모릅니다!

      ### 4-1 ) 사용자가 스케줄링 할 일정을 선택하는 경우
      - 일정 목록을 보여주고, 원하는 스케줄링 일정을 선택 (index 여러개 입력하는 방식으로?)
      - 선택한 일정 -> 고유 id로 변환해서 일정을 인식하는 과정 필요 (배열index -> 해당 id 이런식으로)
      - 선택된 일정들을 schedule 배열 등에 담아주기
        <br>이 일정들을 가중치에 따라 정렬하고,
        <br>정렬된 결과를 화면에 표시 -> 논점 A
      ### 4-2 ) 특정 기간 내의 일정 스케줄링을 제공하는 경우
      - 스케줄링 했으면 하는 기간을 입력받기
      - 해당 기간 내의 일정을 똑같이 schedule 배열에 담아주기
        <br>이 일정들을 가중치에 따라 정렬하고,
        <br>정렬된 결과를 화면에 표시 -> 논점 A
      ### 논점 A: 선택 범위가 월, 주, 일 범위를 벗어나는 경우
      - 원하는 일정, 혹은 선택된 기간이
      <br>현재 우리가 제공하는 월, 주, 일의 범위를 벗어나는 경우에 어떤 식으로 제공할 건가에 대한 의문입니다.
      - gpt 답변으로는 1주, 2주 이런 식으로 여러개를 보여주는 방법으로
        <br> 혹은 더 넓은 범위를 보시겠습니까? 의 입력을 통해서 하거나 하는 예시를 들어줬습니다.
  - 이 외의 값은 default로 재입력 요청
## 3. 프로그램 종료
  - 0이 들어오는 경우 while이 깨지며 종료로 넘어옴
  - Event 배열, Habit 배열, last_id 값을 각 txt 파일에 저장 
    - w 모드로 하면 기존 파일을 삭제하고 새로 적기 때문에, 오류 없이 기록 가능
  - 강제 종료와 같은 부분은 잘 모르겠습니다.
